apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: gpu-papermill-execution-production-init
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/name: gpu-papermill-execution-production-init
    app.kubernetes.io/component: tekton-task
    app.kubernetes.io/version: "1.0.0"
    production-ready: "true"
    security-model: "init-container-permissions"
  annotations:
    tekton.dev/categories: "GPU,Scientific Computing,Production"
    tekton.dev/pipelines.minVersion: "0.50.0"
    tekton.dev/tags: "gpu,rapids,papermill,production,init-container"
    tekton.dev/displayName: "Production GPU Papermill Execution with Init Container"
spec:
  description: |
    Production-grade GPU-accelerated Papermill execution using Init Container pattern.
    
    Architecture:
    - Init Container (root): Fixes conda and workspace permissions
    - Main Container (ubuntu): Executes notebook with proper user context
    
    This approach:
    - Maintains Docker Compose compatibility (ubuntu user execution)
    - Follows Kubernetes security best practices (minimal privileges)
    - Provides production-ready reliability and maintainability
    - Separates permission setup from business logic
  
  params:
  - name: notebook-relative-dir
    description: Relative directory containing the notebook
    type: string
    default: "notebooks"
  - name: notebook-filename
    description: Notebook filename to execute
    type: string
    default: "01_scRNA_analysis_preprocessing.ipynb"
  - name: output-notebook
    description: Name for the output notebook
    type: string
    default: "01_scRNA_analysis_preprocessing_output.ipynb"
  - name: container-image
    description: Container image to use for execution
    type: string
    default: "nvcr.io/nvidia/rapidsai/notebooks:25.04-cuda12.8-py3.12"
  - name: enable-rmm-compatibility
    description: Enable RMM compatibility mode for better error handling
    type: string
    default: "true"
  
  workspaces:
  - name: shared-storage
    description: Shared workspace for input/output files
    mountPath: /workspace/shared
  
  results:
  - name: execution-status
    description: Status of papermill execution
  - name: output-notebook-path
    description: Path to the executed notebook
  - name: papermill-log-path
    description: Path to the papermill execution log
  - name: permission-fix-status
    description: Status of permission fixes applied by init container
  
  stepTemplate:
    env:
    - name: NVIDIA_VISIBLE_DEVICES
      value: "all"
    - name: NVIDIA_DRIVER_CAPABILITIES
      value: "compute,utility"
    - name: WORKSPACE_SHARED_PATH
      value: $(workspaces.shared-storage.path)
    - name: DOCKER_WRITEABLE_DIR
      value: "/workspace/shared/artifacts"
    - name: NOTEBOOK_RELATIVED_DIR
      value: $(params.notebook-relative-dir)
    - name: NOTEBOOK_FILENAME
      value: $(params.notebook-filename)
    - name: OUTPUT_NOTEBOOK
      value: $(params.output-notebook)
    - name: EXTRA_PIP_PACKAGES
      value: "anndata==0.11.4 array-api-compat==1.12.0 contourpy==1.3.2 cycler==0.12.1 fonttools==4.58.0 h5py==3.13.0 imageio==2.37.0 joblib==1.5.1 kiwisolver==1.4.8 lazy-loader==0.4 legacy-api-wrap==1.4.1 llvmlite==0.44.0 matplotlib==3.10.3 natsort==8.4.0 networkx==3.4.2 numba==0.61.2 numpy==2.2.6 pandas==2.2.3 patsy==1.0.1 pillow==11.2.1 pynndescent==0.5.13 rapids-singlecell==0.12.6 scanpy==1.11.2 scikit-image==0.25.2 scikit-misc==0.5.1 scipy==1.15.3 seaborn==0.13.2 session-info2==0.1.2 statsmodels==0.14.4 threadpoolctl==3.6.0 tifffile==2025.5.10 tqdm==4.67.1 tzdata==2025.2 umap-learn==0.5.7 wget==3.2 deprecated==1.2.18 numcodecs==0.15.1 wrapt==1.17.2 zarr==2.18.7"
    volumeMounts:
    - name: dshm
      mountPath: /dev/shm
    - name: conda-permission-fix
      mountPath: /opt/conda-writable
  
  steps:
  # Step 1: Init Container - Permission Setup (root privileges)
  - name: init-permission-setup
    image: $(params.container-image)
    computeResources:
      requests:
        memory: 1Gi
        cpu: 500m
      limits:
        memory: 2Gi
        cpu: 1
    securityContext:
      allowPrivilegeEscalation: true
      capabilities:
        drop: ["ALL"]
        add: ["CHOWN", "DAC_OVERRIDE", "FOWNER"]
      runAsNonRoot: false
      runAsUser: 0  # Init container runs as root for permission fixes
      runAsGroup: 0
      seccompProfile:
        type: RuntimeDefault
    env:
    - name: UBUNTU_UID
      value: "1000"
    - name: UBUNTU_GID
      value: "1000"
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  PRODUCTION INIT CONTAINER - PERMISSION SETUP"
      echo "=============================================="
      echo ""
      echo "Running permission setup as: $(whoami) ($(id))"
      echo "Target Ubuntu UID/GID: ${UBUNTU_UID}/${UBUNTU_GID}"
      echo ""
      
      # Verify ubuntu user exists
      if id ubuntu >/dev/null 2>&1; then
        echo "‚úÖ Ubuntu user found: $(id ubuntu)"
      else
        echo "‚ùå Ubuntu user not found, creating..."
        useradd -u ${UBUNTU_UID} -g ${UBUNTU_GID} -m -s /bin/bash ubuntu || echo "User may already exist"
      fi
      
      # Create conda writable copy for ubuntu user
      echo "üìÅ Setting up conda environment for ubuntu user..."
      
      # Copy conda to writable location for ubuntu user
      if [ ! -d "/opt/conda-writable" ]; then
        echo "Creating writable conda copy..."
        cp -r /opt/conda /opt/conda-writable/
      fi
      
      # Fix conda permissions for ubuntu user
      echo "üîß Fixing conda permissions..."
      chown -R ${UBUNTU_UID}:${UBUNTU_GID} /opt/conda-writable/ || echo "WARNING: Some chown operations failed"
      chmod -R 755 /opt/conda-writable/ || echo "WARNING: Some chmod operations failed"
      
      # Specifically fix key conda directories
      for dir in bin lib python3.12 envs; do
        if [ -d "/opt/conda-writable/$dir" ]; then
          echo "Fixing /opt/conda-writable/$dir"
          chown -R ${UBUNTU_UID}:${UBUNTU_GID} "/opt/conda-writable/$dir" 2>/dev/null || true
          chmod -R 755 "/opt/conda-writable/$dir" 2>/dev/null || true
        fi
      done
      
      # Fix workspace permissions
      echo "üîß Fixing workspace permissions..."
      if [ -d "${WORKSPACE_SHARED_PATH}" ]; then
        chown -R ${UBUNTU_UID}:${UBUNTU_GID} "${WORKSPACE_SHARED_PATH}" || echo "WARNING: Workspace chown failed"
        chmod -R 755 "${WORKSPACE_SHARED_PATH}" || echo "WARNING: Workspace chmod failed"
      fi
      
      # Create and fix output directories
      mkdir -p "${DOCKER_WRITEABLE_DIR}"
      chown -R ${UBUNTU_UID}:${UBUNTU_GID} "${DOCKER_WRITEABLE_DIR}" || echo "WARNING: Output dir chown failed"
      chmod -R 777 "${DOCKER_WRITEABLE_DIR}" || echo "WARNING: Output dir chmod failed"
      
      # Create ubuntu home directory if it doesn't exist
      if [ ! -d "/home/ubuntu" ]; then
        mkdir -p /home/ubuntu
        chown ${UBUNTU_UID}:${UBUNTU_GID} /home/ubuntu
        chmod 755 /home/ubuntu
      fi
      
      # Write permission fix status
      echo "success" > "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      chown ${UBUNTU_UID}:${UBUNTU_GID} "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt" || true
      
      echo ""
      echo "‚úÖ PERMISSION SETUP COMPLETED"
      echo "üìã Summary:"
      echo "   - Conda permissions fixed for ubuntu user"
      echo "   - Workspace permissions configured"
      echo "   - Output directories prepared"
      echo "   - Ready for main container execution"
      echo ""
  
  # Step 2: Main Container - Notebook Execution (ubuntu user)
  - name: execute-notebook-as-ubuntu
    image: $(params.container-image)
    computeResources:
      requests:
        nvidia.com/gpu: 1
        memory: 16Gi
        cpu: 4
      limits:
        nvidia.com/gpu: 1
        memory: 32Gi
        cpu: 8
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
        add: ["IPC_LOCK", "SYS_RESOURCE"]
      runAsNonRoot: true
      runAsUser: 1000  # Ubuntu user - Docker Compose compatible
      runAsGroup: 1000
      seccompProfile:
        type: RuntimeDefault
    env:
    - name: HOME
      value: "/home/ubuntu"
    - name: USER
      value: "ubuntu"
    - name: PATH
      value: "/home/ubuntu/.local/bin:/opt/conda-writable/bin:/usr/local/bin:/usr/bin:/bin"
    - name: PYTHONPATH
      value: "/opt/conda-writable/lib/python3.12/site-packages"
    - name: CONDA_DEFAULT_ENV
      value: "base"
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  PRODUCTION MAIN CONTAINER - NOTEBOOK EXECUTION"
      echo "=============================================="
      echo ""
      echo "Running as: $(whoami) ($(id))"
      echo "Home: $HOME"
      echo "Path: $PATH"
      echo ""
      
      # Apply Docker Compose compatible memory settings
      echo "üîß Applying Docker Compose compatible memory settings..."
      ulimit -l unlimited 2>/dev/null || echo "WARNING: Cannot set unlimited memlock"
      ulimit -s 67108864 2>/dev/null || echo "WARNING: Cannot set stack size"
      
      # Verify init container completed successfully
      if [ -f "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt" ]; then
        INIT_STATUS=$(cat "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt")
        echo "‚úÖ Init container status: $INIT_STATUS"
      else
        echo "‚ùå Init container status not found"
        exit 1
      fi
      
      cd "${WORKSPACE_SHARED_PATH}"
      
      # Verify GPU availability
      echo "üîç Checking GPU availability..."
      nvidia-smi --query-gpu=name,memory.total --format=csv,noheader || echo "WARNING: nvidia-smi failed"
      
      # Verify notebook exists
      NOTEBOOK_PATH="${NOTEBOOK_RELATIVED_DIR}/${NOTEBOOK_FILENAME}"
      if [ ! -f "${NOTEBOOK_PATH}" ]; then
        echo "‚ùå Notebook not found: ${NOTEBOOK_PATH}"
        find . -name "*.ipynb" -type f | head -5
        exit 1
      fi
      
      echo "‚úÖ Notebook found: ${NOTEBOOK_PATH}"
      
      # Setup Python environment using fixed conda installation
      echo "üêç Setting up Python environment..."
      
      PYTHON_BIN="/opt/conda-writable/bin/python"
      PIP_BIN="/opt/conda-writable/bin/pip"
      CONDA_BIN="/opt/conda-writable/bin/conda"
      
      # Verify Python environment access
      echo "üîç Python environment verification:"
      $PYTHON_BIN --version && echo "‚úÖ Python OK" || (echo "‚ùå Python failed" && exit 1)
      $PIP_BIN --version && echo "‚úÖ pip OK" || (echo "‚ùå pip failed" && exit 1)
      $CONDA_BIN --version && echo "‚úÖ conda OK" || (echo "‚ùå conda failed" && exit 1)
      
      # Install dependencies using ubuntu user's conda
      echo "üì¶ Installing dependencies..."
      $PIP_BIN install --user --quiet --no-cache-dir papermill ipykernel jupyter || {
        echo "‚ùå Failed to install papermill"
        exit 1
      }
      
      # Install additional packages
      if [ -n "${EXTRA_PIP_PACKAGES:-}" ]; then
        echo "üì¶ Installing additional packages..."
        
        # Install scanpy with conda first for better compatibility
        echo "Installing scanpy with conda..."
        $CONDA_BIN install -y -c conda-forge -c bioconda scanpy || {
          echo "WARNING: Conda scanpy failed, trying pip..."
          $PIP_BIN install --user --quiet --no-cache-dir scanpy || echo "WARNING: scanpy installation failed"
        }
        
        # Install other packages with pip
        echo "Installing other packages with pip..."
        $PIP_BIN install --user --quiet --no-cache-dir ${EXTRA_PIP_PACKAGES} || echo "WARNING: Some pip packages failed"
        
        # Verify key packages
        echo "üîç Verifying package installations..."
        $PYTHON_BIN -c "import scanpy as sc; print('SUCCESS: scanpy version:', sc.__version__)" || {
          echo "WARNING: scanpy verification failed, trying direct install..."
          $PIP_BIN install --user --force-reinstall scanpy
          $PYTHON_BIN -c "import scanpy as sc; print('SUCCESS: scanpy version:', sc.__version__)" || echo "WARNING: scanpy still not working"
        }
        
        $PYTHON_BIN -c "import cupy as cp; print('SUCCESS: cupy GPU count:', cp.cuda.runtime.getDeviceCount())" || echo "WARNING: cupy verification failed"
        
        # RMM compatibility test if enabled
        if [ "$(params.enable-rmm-compatibility)" = "true" ]; then
          echo "üß™ Testing RMM compatibility..."
          # Use heredoc to avoid quote issues
          $PYTHON_BIN << 'EOF'
import warnings
warnings.filterwarnings('ignore')

try:
    import rmm
    from rmm.allocators.cupy import rmm_cupy_allocator
    import cupy as cp
    
    # Safe RMM initialization
    rmm.reinitialize(
        managed_memory=False,
        pool_allocator=False,
        devices=0,
    )
    cp.cuda.set_allocator(rmm_cupy_allocator)
    print('SUCCESS: RMM initialized successfully')
except Exception as e:
    print(f'INFO: RMM initialization failed, using default allocator: {e}')
    print('This is normal and the notebook should still work')
EOF
        fi
      fi
      
      # Setup GPU environment
      export CUDA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-"all"}
      export CUPY_CACHE_DIR="${HOME}/.cupy"
      export NUMBA_CACHE_DIR="${HOME}/.numba"
      mkdir -p "${CUPY_CACHE_DIR}" "${NUMBA_CACHE_DIR}" 2>/dev/null || echo "WARNING: Cannot create cache dirs"
      
      # Find papermill executable
      PAPERMILL_BIN=""
      if [ -x "/home/ubuntu/.local/bin/papermill" ]; then
        PAPERMILL_BIN="/home/ubuntu/.local/bin/papermill"
      elif [ -x "/opt/conda-writable/bin/papermill" ]; then
        PAPERMILL_BIN="/opt/conda-writable/bin/papermill"
      else
        echo "‚ùå papermill not found after installation"
        exit 1
      fi
      
      # Execute notebook with EXACT GitHub Actions parameters
      echo "üöÄ Executing notebook with Papermill..."
      PAPERMILL_OUTPUT_PATH="${DOCKER_WRITEABLE_DIR}/${OUTPUT_NOTEBOOK}"
      PAPERMILL_LOG_PATH="${DOCKER_WRITEABLE_DIR}/papermill.log"
      
      echo "Command: $PAPERMILL_BIN \"${NOTEBOOK_PATH}\" \"${PAPERMILL_OUTPUT_PATH}\" --log-output --log-level DEBUG --progress-bar --report-mode --kernel python3"
      
      # Execute with EXACT same parameters as GitHub Actions
      PAPERMILL_EXIT_CODE=0
      $PAPERMILL_BIN "${NOTEBOOK_PATH}" "${PAPERMILL_OUTPUT_PATH}" \
          --log-output \
          --log-level DEBUG \
          --progress-bar \
          --report-mode \
          --kernel python3 2>&1 | tee "${PAPERMILL_LOG_PATH}" || PAPERMILL_EXIT_CODE=$?
      
      # Check results
      if [ $PAPERMILL_EXIT_CODE -ne 0 ]; then
        echo "‚ùå Papermill execution failed with exit code: $PAPERMILL_EXIT_CODE"
        echo "Last 20 lines of papermill log:"
        tail -20 "${PAPERMILL_LOG_PATH}" || true
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      # Check for execution errors
      if grep -q "PapermillExecutionError" "${PAPERMILL_LOG_PATH}"; then
        echo "‚ùå Papermill execution failed - PapermillExecutionError found"
        echo "Last 20 lines of papermill log:"
        tail -20 "${PAPERMILL_LOG_PATH}" || true
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      # Verify output
      if [ -f "${PAPERMILL_OUTPUT_PATH}" ]; then
        OUTPUT_SIZE=$(du -h "${PAPERMILL_OUTPUT_PATH}" | cut -f1)
        echo "‚úÖ SUCCESS: Output notebook created: ${OUTPUT_SIZE}"
        echo -n "success" > "$(results.execution-status.path)"
        echo -n "${PAPERMILL_OUTPUT_PATH}" > "$(results.output-notebook-path.path)"
        echo -n "${PAPERMILL_LOG_PATH}" > "$(results.papermill-log-path.path)"
        echo -n "success" > "$(results.permission-fix-status.path)"
      else
        echo "‚ùå Output notebook not found"
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      echo ""
      echo "üéâ PRODUCTION EXECUTION COMPLETED!"
      echo "‚úÖ Docker Compose compatibility achieved"
      echo "‚úÖ Kubernetes security best practices followed"
      echo "‚úÖ Init Container pattern successfully implemented"
      echo ""
  
  volumes:
  - name: dshm
    emptyDir:
      medium: Memory
      sizeLimit: 1Gi
  - name: conda-permission-fix
    emptyDir:
      sizeLimit: 5Gi 
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: safe-git-clone
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/name: safe-git-clone
    app.kubernetes.io/component: tekton-task
    app.kubernetes.io/version: "1.0.0"
spec:
  description: |
    Safe git clone task with automatic handling of existing directories.
    Features:
    - Automatic backup of existing content
    - Safe directory cleanup
    - Retry mechanism
    - Comprehensive validation
    - Rollback capability
    
  params:
  - name: git-repo-url
    description: Git repository URL to clone
    type: string
  - name: git-revision
    description: Git revision to checkout (commit hash, branch, or tag)
    type: string
    default: "main"
  - name: workspace-subdir
    description: Subdirectory within workspace to clone repository
    type: string
    default: "source"
  - name: backup-existing
    description: Whether to backup existing directory before removal
    type: string
    default: "true"
  - name: force-clean
    description: Force clean without backup (use with caution)
    type: string
    default: "false"
  - name: max-retries
    description: Maximum number of clone retry attempts
    type: string
    default: "3"
  - name: verbose
    description: Enable verbose logging
    type: string
    default: "true"
    
  workspaces:
  - name: source-workspace
    description: Workspace for source code
    mountPath: /workspace/source
  
  results:
  - name: commit-sha
    description: SHA of the checked out commit
  - name: clone-status
    description: Status of the clone operation
  - name: backup-path
    description: Path to backup if created
    
  steps:
  - name: safe-git-clone
    image: alpine/git:latest
    env:
    - name: WORKSPACE_PATH
      value: $(workspaces.source-workspace.path)
    - name: TARGET_DIR
      value: $(params.workspace-subdir)
    - name: REPO_URL
      value: $(params.git-repo-url)
    - name: REVISION
      value: $(params.git-revision)
    - name: BACKUP_ENABLED
      value: $(params.backup-existing)
    - name: FORCE_CLEAN
      value: $(params.force-clean)
    - name: MAX_RETRIES
      value: $(params.max-retries)
    - name: VERBOSE
      value: $(params.verbose)
    script: |
      #!/bin/sh
      set -eu
      
      # Function to log with timestamps
      log() {
        echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
      }
      
      log "🚀 Starting safe git clone operation..."
      log "📁 Workspace: ${WORKSPACE_PATH}"
      log "📂 Target directory: ${TARGET_DIR}" 
      log "🔗 Repository: ${REPO_URL}"
      log "🌿 Revision: ${REVISION}"
      
      cd "${WORKSPACE_PATH}"
      
      # Initialize result variables
      BACKUP_PATH=""
      CLONE_STATUS="failed"
      
      # Function to handle existing directory
      handle_existing_directory() {
        local target_dir="$1"
        
        if [ ! -d "${target_dir}" ]; then
          log "✅ Target directory doesn't exist, proceeding with clone"
          return 0
        fi
        
        log "⚠️  Target directory '${target_dir}' already exists"
        
        # Check if force clean is enabled
        if [ "${FORCE_CLEAN}" = "true" ]; then
          log "🧹 Force clean enabled, removing existing directory"
          rm -rf "${target_dir}"
          return 0
        fi
        
        # Check if backup is enabled
        if [ "${BACKUP_ENABLED}" = "true" ]; then
          local timestamp=$(date '+%Y%m%d_%H%M%S')
          local backup_dir="${target_dir}_backup_${timestamp}"
          
          log "💾 Creating backup: ${backup_dir}"
          
          # Create backup
          if mv "${target_dir}" "${backup_dir}"; then
            log "✅ Backup created successfully: ${backup_dir}"
            BACKUP_PATH="${WORKSPACE_PATH}/${backup_dir}"
            echo -n "${BACKUP_PATH}" > "$(results.backup-path.path)"
          else
            log "❌ Failed to create backup"
            return 1
          fi
        else
          log "🧹 Backup disabled, removing existing directory"
          rm -rf "${target_dir}"
        fi
        
        return 0
      }
      
      # Function to validate git repository
      validate_repository() {
        local repo_dir="$1"
        
        if [ ! -d "${repo_dir}/.git" ]; then
          log "❌ Invalid git repository: .git directory not found"
          return 1
        fi
        
        cd "${repo_dir}"
        
        # Check if repository is clean
        if ! git status > /dev/null 2>&1; then
          log "❌ Git repository appears to be corrupted"
          return 1
        fi
        
        # Validate commit SHA
        local commit_sha=$(git rev-parse HEAD)
        if [ -z "${commit_sha}" ]; then
          log "❌ Unable to retrieve commit SHA"
          return 1
        fi
        
        log "📌 Repository validated, commit SHA: ${commit_sha}"
        echo -n "${commit_sha}" > "$(results.commit-sha.path)"
        
        return 0
      }
      
      # Function to perform git clone with retries
      perform_git_clone() {
        local target_dir="$1"
        local attempt=1
        
        while [ ${attempt} -le ${MAX_RETRIES} ]; do
          log "🔄 Clone attempt ${attempt}/${MAX_RETRIES}"
          
          # Perform the clone
          if [ "${VERBOSE}" = "true" ]; then
            if git clone --verbose "${REPO_URL}" "${target_dir}"; then
              log "✅ Git clone successful on attempt ${attempt}"
              return 0
            fi
          else
            if git clone "${REPO_URL}" "${target_dir}" 2>&1; then
              log "✅ Git clone successful on attempt ${attempt}"
              return 0
            fi
          fi
          
          log "❌ Clone attempt ${attempt} failed"
          
          # Clean up partial clone on failure
          if [ -d "${target_dir}" ]; then
            log "🧹 Cleaning up partial clone"
            rm -rf "${target_dir}"
          fi
          
          # Wait before retry (exponential backoff)
          if [ ${attempt} -lt ${MAX_RETRIES} ]; then
            local wait_time=$((attempt * 5))
            log "⏳ Waiting ${wait_time} seconds before retry"
            sleep ${wait_time}
          fi
          
          attempt=$((attempt + 1))
        done
        
        log "❌ All clone attempts failed"
        return 1
      }
      
      # Function to checkout specific revision
      checkout_revision() {
        local target_dir="$1"
        
        cd "${target_dir}"
        
        if [ "${REVISION}" != "main" ] && [ "${REVISION}" != "master" ]; then
          log "🔄 Checking out revision: ${REVISION}"
          
          # Fetch if the revision might be a remote branch or tag
          git fetch origin 2>/dev/null || true
          
          if git checkout "${REVISION}"; then
            log "✅ Successfully checked out revision: ${REVISION}"
          else
            log "❌ Failed to checkout revision: ${REVISION}"
            return 1
          fi
        else
          log "ℹ️  Using default branch: ${REVISION}"
        fi
        
        return 0
      }
      
      # Function to rollback on failure
      rollback_on_failure() {
        if [ -n "${BACKUP_PATH}" ] && [ -d "${BACKUP_PATH}" ]; then
          log "🔄 Rolling back from backup: ${BACKUP_PATH}"
          local original_name=$(basename "${BACKUP_PATH}" | sed 's/_backup_[0-9]*_[0-9]*$//')
          
          if mv "${BACKUP_PATH}" "${original_name}"; then
            log "✅ Rollback successful"
          else
            log "❌ Rollback failed"
          fi
        fi
      }
      
      # Main execution flow
      main() {
        log "🎯 Starting main execution flow"
        
        # Step 1: Handle existing directory
        if ! handle_existing_directory "${TARGET_DIR}"; then
          log "❌ Failed to handle existing directory"
          return 1
        fi
        
        # Step 2: Perform git clone with retries
        if ! perform_git_clone "${TARGET_DIR}"; then
          log "❌ Git clone failed after all retries"
          rollback_on_failure
          return 1
        fi
        
        # Step 3: Checkout specific revision
        if ! checkout_revision "${TARGET_DIR}"; then
          log "❌ Failed to checkout revision"
          rollback_on_failure
          return 1
        fi
        
        # Step 4: Validate repository
        if ! validate_repository "${TARGET_DIR}"; then
          log "❌ Repository validation failed"
          rollback_on_failure
          return 1
        fi
        
        # Step 5: Final validation and cleanup
        cd "${TARGET_DIR}"
        
        # Check for expected directories/files
        if [ -d "notebooks" ]; then
          log "✅ notebooks/ directory found"
          ls -la notebooks/ | head -5
        fi
        
        if [ -d "examples" ]; then
          log "✅ examples/ directory found"
        fi
        
        if [ -f "README.md" ]; then
          log "✅ README.md found"
        fi
        
        # Set successful status
        CLONE_STATUS="success"
        echo -n "${CLONE_STATUS}" > "$(results.clone-status.path)"
        
        log "🎉 Safe git clone completed successfully!"
        return 0
      }
      
      # Execute main function with error handling
      if main; then
        log "✅ Operation completed successfully"
        exit 0
      else
        log "❌ Operation failed"
        echo -n "failed" > "$(results.clone-status.path)"
        exit 1
      fi 
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: gpu-papermill-execution-production-init
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/name: gpu-papermill-execution-production-init
    app.kubernetes.io/component: tekton-task
    app.kubernetes.io/version: "1.0.0"
    production-ready: "true"
    security-model: "init-container-permissions"
    rmm-compatibility: "fixed"
spec:
  description: |
    Production-grade GPU-accelerated Papermill execution with RMM compatibility fixes.
    
    Architecture:
    - Init Container (root): Fixes conda and workspace permissions for RAPIDS user (UID 1001)
    - Main Container (rapids): Executes notebook with RMM error handling
    
    IMPROVEMENTS: Handles RMM compatibility issues with graceful fallback
  
  params:
  - name: notebook-relative-dir
    description: Relative directory containing the notebook
    type: string
    default: "notebooks"
  - name: notebook-filename
    description: Notebook filename to execute
    type: string
    default: "01_scRNA_analysis_preprocessing.ipynb"
  - name: output-notebook
    description: Name for the output notebook
    type: string
    default: "01_scRNA_analysis_preprocessing_output.ipynb"
  - name: container-image
    description: Container image to use for execution
    type: string
    default: "nvcr.io/nvidia/rapidsai/notebooks:25.04-cuda12.8-py3.12"
  - name: enable-rmm-compatibility
    description: Enable RMM compatibility fixes
    type: string
    default: "true"
  
  workspaces:
  - name: shared-storage
    description: Shared workspace for input/output files
    mountPath: /workspace/shared
  
  results:
  - name: execution-status
    description: Status of papermill execution
  - name: output-notebook-path
    description: Path to the executed notebook
  - name: papermill-log-path
    description: Path to the papermill execution log
  - name: permission-fix-status
    description: Status of permission fixes applied by init container
  - name: rmm-compatibility-status
    description: Status of RMM compatibility handling
  
  stepTemplate:
    env:
    - name: NVIDIA_VISIBLE_DEVICES
      value: "all"
    - name: NVIDIA_DRIVER_CAPABILITIES
      value: "compute,utility"
    - name: WORKSPACE_SHARED_PATH
      value: $(workspaces.shared-storage.path)
    - name: DOCKER_WRITEABLE_DIR
      value: "/workspace/shared/artifacts"
    - name: NOTEBOOK_RELATIVED_DIR
      value: $(params.notebook-relative-dir)
    - name: NOTEBOOK_FILENAME
      value: $(params.notebook-filename)
    - name: OUTPUT_NOTEBOOK
      value: $(params.output-notebook)
    - name: EXTRA_PIP_PACKAGES
      value: "anndata==0.11.4 scanpy==1.11.2 rapids-singlecell==0.12.6"
    volumeMounts:
    - name: dshm
      mountPath: /dev/shm
    - name: conda-permission-fix
      mountPath: /opt/conda-writable
  
  steps:
  # Step 1: Init Container - Permission Setup (root privileges)
  - name: init-permission-setup
    image: $(params.container-image)
    computeResources:
      requests:
        memory: 1Gi
        cpu: 500m
      limits:
        memory: 2Gi
        cpu: 1
    securityContext:
      allowPrivilegeEscalation: true
      capabilities:
        drop: ["ALL"]
        add: ["CHOWN", "DAC_OVERRIDE", "FOWNER"]
      runAsNonRoot: false
      runAsUser: 0  # Init container runs as root for permission fixes
      runAsGroup: 0
      seccompProfile:
        type: RuntimeDefault
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  PRODUCTION INIT CONTAINER - RAPIDS USER UID FIX"
      echo "=============================================="
      echo ""
      echo "Running permission setup as: $(whoami) ($(id))"
      
      # Get actual rapids user UID from the container
      if id rapids >/dev/null 2>&1; then
        RAPIDS_UID=$(id -u rapids)
        RAPIDS_GID=$(id -g rapids)
        echo "✅ RAPIDS user found with actual UID: $(id rapids)"
        echo "   Actual UID: $RAPIDS_UID, GID: $RAPIDS_GID"
      else
        echo "❌ RAPIDS user not found, this should not happen in this image"
        exit 1
      fi
      
      # Fix conda permissions for ACTUAL rapids user UID
      echo "🔧 Fixing conda permissions for RAPIDS user (ACTUAL UID: $RAPIDS_UID)..."
      chown -R $RAPIDS_UID:$RAPIDS_GID /opt/conda/ 2>/dev/null || echo "WARNING: Cannot change original conda ownership"
      chmod -R 755 /opt/conda/ 2>/dev/null || echo "WARNING: Cannot change original conda permissions"
      
      # Fix workspace permissions
      echo "🔧 Fixing workspace permissions for RAPIDS user..."
      if [ -d "${WORKSPACE_SHARED_PATH}" ]; then
        chown -R $RAPIDS_UID:$RAPIDS_GID "${WORKSPACE_SHARED_PATH}" || echo "WARNING: Workspace chown failed"
        chmod -R 755 "${WORKSPACE_SHARED_PATH}" || echo "WARNING: Workspace chmod failed"
      fi
      
      # Create and fix output directories
      mkdir -p "${DOCKER_WRITEABLE_DIR}"
      chown -R $RAPIDS_UID:$RAPIDS_GID "${DOCKER_WRITEABLE_DIR}" || echo "WARNING: Output dir chown failed"
      chmod -R 777 "${DOCKER_WRITEABLE_DIR}" || echo "WARNING: Output dir chmod failed"
      
      # Ensure rapids home directory exists and has correct permissions
      if [ ! -d "/home/rapids" ]; then
        mkdir -p /home/rapids
        echo "✅ Created /home/rapids directory"
      fi
      chown $RAPIDS_UID:$RAPIDS_GID /home/rapids
      chmod 755 /home/rapids
      echo "✅ /home/rapids permissions set for UID $RAPIDS_UID"
      
      # Write permission fix status with CORRECT user info
      echo "success" > "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      echo "rapids-user-uid:$RAPIDS_UID" >> "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      echo "rapids-user-gid:$RAPIDS_GID" >> "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      chown $RAPIDS_UID:$RAPIDS_GID "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt" || true
      
      echo ""
      echo "✅ PERMISSION SETUP COMPLETED FOR RAPIDS USER"
      echo "📋 Summary:"
      echo "   - RAPIDS user: ACTUAL UID $RAPIDS_UID, GID $RAPIDS_GID"
      echo "   - Conda permissions fixed for rapids user"
      echo "   - Workspace permissions configured"
      echo "   - Output directories prepared"
      echo "   - Ready for main container execution as rapids user UID $RAPIDS_UID"
      echo ""

  # Step 2: RMM Compatibility Setup
  - name: rmm-compatibility-setup
    image: $(params.container-image)
    computeResources:
      requests:
        memory: 2Gi
        cpu: 1
      limits:
        memory: 4Gi
        cpu: 2
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
      runAsNonRoot: true
      runAsUser: 1001  # rapids user
      runAsGroup: 1001
      seccompProfile:
        type: RuntimeDefault
    env:
    - name: HOME
      value: "/home/rapids"
    - name: USER
      value: "rapids"
    - name: PATH
      value: "/home/rapids/.local/bin:/opt/conda/bin:/usr/local/bin:/usr/bin:/bin"
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  RMM COMPATIBILITY SETUP"
      echo "=============================================="
      echo ""
      echo "Running as: $(whoami) ($(id))"
      
      cd "${WORKSPACE_SHARED_PATH}"
      
      # Create RMM compatibility script
      echo "📝 Creating RMM compatibility script..."
      cat > "${DOCKER_WRITEABLE_DIR}/rmm_compatibility.py" << 'EOF'
import warnings
warnings.filterwarnings("ignore")

def setup_rmm_with_fallback():
    """Setup RMM with graceful fallback to default allocator"""
    try:
        import rmm
        from rmm.allocators.cupy import rmm_cupy_allocator
        import cupy as cp
        
        print("🔧 Attempting RMM initialization...")
        
        # Try RMM initialization with error handling
        rmm.reinitialize(
            managed_memory=False,
            pool_allocator=False,
            devices=0,
        )
        cp.cuda.set_allocator(rmm_cupy_allocator)
        
        print("✅ RMM initialized successfully")
        return True
        
    except Exception as e:
        print(f"⚠️ RMM initialization failed: {e}")
        print("🔄 Falling back to default CuPy allocator...")
        
        try:
            import cupy as cp
            # Reset to default allocator
            cp.cuda.set_allocator(None)
            print("✅ Default CuPy allocator configured")
            return False
        except Exception as fallback_e:
            print(f"❌ Fallback also failed: {fallback_e}")
            return False

def test_gpu_basic_functionality():
    """Test basic GPU functionality after allocator setup"""
    try:
        import cupy as cp
        device_count = cp.cuda.runtime.getDeviceCount()
        print(f"✅ GPU devices detected: {device_count}")
        
        if device_count > 0:
            # Test basic GPU operation
            x = cp.array([1, 2, 3])
            y = cp.sum(x)
            print(f"✅ Basic GPU operation successful: {y}")
            return True
        else:
            print("❌ No GPU devices found")
            return False
            
    except Exception as e:
        print(f"❌ GPU functionality test failed: {e}")
        return False

if __name__ == "__main__":
    print("🚀 Starting RMM compatibility setup...")
    
    rmm_success = setup_rmm_with_fallback()
    gpu_success = test_gpu_basic_functionality()
    
    if gpu_success:
        print("✅ GPU functionality verified")
        print("ready" if rmm_success else "fallback")
    else:
        print("❌ GPU functionality verification failed")
        print("failed")
EOF
      
      # Run RMM compatibility setup
      echo "🚀 Running RMM compatibility setup..."
      PYTHON_BIN="/opt/conda/bin/python"
      
      if [ -x "$PYTHON_BIN" ]; then
        $PYTHON_BIN "${DOCKER_WRITEABLE_DIR}/rmm_compatibility.py" > "${DOCKER_WRITEABLE_DIR}/rmm_setup.log" 2>&1
        RMM_EXIT_CODE=$?
        
        echo "📋 RMM compatibility setup results:"
        cat "${DOCKER_WRITEABLE_DIR}/rmm_setup.log"
        
        if [ $RMM_EXIT_CODE -eq 0 ]; then
          echo "✅ RMM compatibility setup completed successfully"
          echo -n "success" > "$(results.rmm-compatibility-status.path)"
        else
          echo "❌ RMM compatibility setup failed"
          echo -n "failed" > "$(results.rmm-compatibility-status.path)"
        fi
      else
        echo "❌ Python not accessible for RMM setup"
        echo -n "failed" > "$(results.rmm-compatibility-status.path)"
      fi
      
      echo ""
      echo "🏁 RMM COMPATIBILITY SETUP COMPLETED"
      echo ""
  
  # Step 3: Main Container - Notebook Execution with RMM handling
  - name: execute-notebook-with-rmm-handling
    image: $(params.container-image)
    computeResources:
      requests:
        nvidia.com/gpu: 1
        memory: 16Gi
        cpu: 4
      limits:
        nvidia.com/gpu: 1
        memory: 32Gi
        cpu: 8
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
        add: ["IPC_LOCK", "SYS_RESOURCE"]
      runAsNonRoot: true
      runAsUser: 1001  # CORRECT: Use actual RAPIDS user UID 1001
      runAsGroup: 1001
      seccompProfile:
        type: RuntimeDefault
    env:
    - name: HOME
      value: "/home/rapids"
    - name: USER
      value: "rapids"
    - name: PATH
      value: "/home/rapids/.local/bin:/opt/conda/bin:/usr/local/bin:/usr/bin:/bin"
    - name: PYTHONPATH
      value: "/opt/conda/lib/python3.12/site-packages"
    - name: CONDA_DEFAULT_ENV
      value: "base"
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  PRODUCTION NOTEBOOK EXECUTION WITH RMM HANDLING"
      echo "=============================================="
      echo ""
      echo "Running as: $(whoami) ($(id))"
      echo "Home: $HOME"
      echo "Path: $PATH"
      echo ""
      
      # Verify we're running as the correct user
      CURRENT_UID=$(id -u)
      if [ "$CURRENT_UID" != "1001" ]; then
        echo "❌ ERROR: Expected to run as UID 1001 (rapids), but running as UID $CURRENT_UID"
        exit 1
      else
        echo "✅ Correctly running as RAPIDS user (UID 1001)"
      fi
      
      # Apply Docker Compose compatible memory settings
      echo "🔧 Applying Docker Compose compatible memory settings..."
      ulimit -l unlimited 2>/dev/null || echo "WARNING: Cannot set unlimited memlock"
      ulimit -s 67108864 2>/dev/null || echo "WARNING: Cannot set stack size"
      
      cd "${WORKSPACE_SHARED_PATH}"
      
      # Verify GPU availability
      echo "🔍 Checking GPU availability..."
      nvidia-smi --query-gpu=name,memory.total --format=csv,noheader || echo "WARNING: nvidia-smi failed"
      
      # Verify notebook exists
      NOTEBOOK_PATH="${NOTEBOOK_RELATIVED_DIR}/${NOTEBOOK_FILENAME}"
      if [ ! -f "${NOTEBOOK_PATH}" ]; then
        echo "❌ Notebook not found: ${NOTEBOOK_PATH}"
        find . -name "*.ipynb" -type f | head -5
        exit 1
      fi
      
      echo "✅ Notebook found: ${NOTEBOOK_PATH}"
      
      # Setup Python environment
      echo "🐍 Setting up Python environment as RAPIDS user (UID 1001)..."
      PYTHON_BIN="/opt/conda/bin/python"
      PIP_BIN="/opt/conda/bin/pip"
      
      # Verify Python environment access
      echo "🔍 Python environment verification:"
      $PYTHON_BIN --version && echo "✅ Python OK" || (echo "❌ Python failed" && exit 1)
      $PIP_BIN --version && echo "✅ pip OK" || (echo "❌ pip failed" && exit 1)
      
      # Install dependencies
      echo "📦 Installing dependencies as RAPIDS user..."
      $PIP_BIN install --user --quiet --no-cache-dir papermill ipykernel jupyter || {
        echo "❌ Failed to install papermill"
        exit 1
      }
      
      # Install additional packages
      if [ -n "${EXTRA_PIP_PACKAGES:-}" ]; then
        echo "📦 Installing additional packages..."
        $PIP_BIN install --user --quiet --no-cache-dir ${EXTRA_PIP_PACKAGES} || echo "WARNING: Some pip packages failed"
      fi
      
      # Check RMM compatibility status
      echo "🔍 Checking RMM compatibility status..."
      if [ -f "${DOCKER_WRITEABLE_DIR}/rmm_setup.log" ]; then
        echo "📋 RMM setup results:"
        cat "${DOCKER_WRITEABLE_DIR}/rmm_setup.log"
      fi
      
      # Create notebook preprocessing script for RMM handling
      echo "📝 Creating notebook preprocessing script..."
      cat > "${DOCKER_WRITEABLE_DIR}/notebook_preprocessor.py" << 'EOF'
import nbformat
import sys

def preprocess_notebook_for_rmm(input_path, output_path):
    """Preprocess notebook to handle RMM initialization gracefully"""
    print(f"📝 Preprocessing notebook: {input_path}")
    
    # Read the original notebook
    with open(input_path, 'r') as f:
        nb = nbformat.read(f, as_version=4)
    
    # Find the RMM initialization cell (usually cell 2 or 3)
    rmm_cell_found = False
    for i, cell in enumerate(nb.cells):
        if cell.cell_type == 'code' and 'rmm.reinitialize' in cell.source:
            print(f"🔧 Found RMM cell at index {i}, applying compatibility fix...")
            
            # Replace the problematic RMM code with error-handled version
            new_source = '''import warnings
warnings.filterwarnings("ignore")

# RMM initialization with error handling
try:
    import rmm
    from rmm.allocators.cupy import rmm_cupy_allocator
    import cupy as cp
    
    print("🔧 Attempting RMM initialization...")
    rmm.reinitialize(
        managed_memory=False,
        pool_allocator=False,
        devices=0,
    )
    cp.cuda.set_allocator(rmm_cupy_allocator)
    print("✅ RMM initialized successfully")
    
except Exception as e:
    print(f"⚠️ RMM initialization failed: {e}")
    print("🔄 Using default CuPy allocator")
    
    try:
        import cupy as cp
        cp.cuda.set_allocator(None)  # Use default allocator
        print("✅ Default allocator configured")
    except Exception as fallback_e:
        print(f"❌ Fallback failed: {fallback_e}")
        # Continue anyway, might still work'''
            
            cell.source = new_source
            rmm_cell_found = True
            break
    
    if not rmm_cell_found:
        print("ℹ️ No RMM initialization cell found, notebook unchanged")
    
    # Write the preprocessed notebook
    with open(output_path, 'w') as f:
        nbformat.write(nb, f)
    
    print(f"✅ Preprocessed notebook saved to: {output_path}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python notebook_preprocessor.py input.ipynb output.ipynb")
        sys.exit(1)
    
    input_notebook = sys.argv[1]
    output_notebook = sys.argv[2]
    
    preprocess_notebook_for_rmm(input_notebook, output_notebook)
EOF
      
      # Preprocess the notebook to handle RMM issues
      PREPROCESSED_NOTEBOOK="${DOCKER_WRITEABLE_DIR}/preprocessed_${NOTEBOOK_FILENAME}"
      echo "🔧 Preprocessing notebook for RMM compatibility..."
      $PYTHON_BIN "${DOCKER_WRITEABLE_DIR}/notebook_preprocessor.py" "${NOTEBOOK_PATH}" "${PREPROCESSED_NOTEBOOK}"
      
      # Setup GPU environment
      export CUDA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-"all"}
      export CUPY_CACHE_DIR="${HOME}/.cupy"
      export NUMBA_CACHE_DIR="${HOME}/.numba"
      mkdir -p "${CUPY_CACHE_DIR}" "${NUMBA_CACHE_DIR}" 2>/dev/null || echo "WARNING: Cannot create cache dirs"
      
      # Find papermill executable
      PAPERMILL_BIN=""
      if [ -x "/home/rapids/.local/bin/papermill" ]; then
        PAPERMILL_BIN="/home/rapids/.local/bin/papermill"
      elif [ -x "/opt/conda/bin/papermill" ]; then
        PAPERMILL_BIN="/opt/conda/bin/papermill"
      else
        echo "❌ papermill not found after installation"
        exit 1
      fi
      
      # Execute preprocessed notebook with Papermill
      echo "🚀 Executing preprocessed notebook with Papermill..."
      PAPERMILL_OUTPUT_PATH="${DOCKER_WRITEABLE_DIR}/${OUTPUT_NOTEBOOK}"
      PAPERMILL_LOG_PATH="${DOCKER_WRITEABLE_DIR}/papermill.log"
      
      echo "Command: $PAPERMILL_BIN \"${PREPROCESSED_NOTEBOOK}\" \"${PAPERMILL_OUTPUT_PATH}\" --log-output --log-level DEBUG --progress-bar --report-mode --kernel python3"
      
      # Execute with EXACT same parameters as GitHub Actions
      PAPERMILL_EXIT_CODE=0
      $PAPERMILL_BIN "${PREPROCESSED_NOTEBOOK}" "${PAPERMILL_OUTPUT_PATH}" \
          --log-output \
          --log-level DEBUG \
          --progress-bar \
          --report-mode \
          --kernel python3 2>&1 | tee "${PAPERMILL_LOG_PATH}" || PAPERMILL_EXIT_CODE=$?
      
      # Check results
      if [ $PAPERMILL_EXIT_CODE -ne 0 ]; then
        echo "❌ Papermill execution failed with exit code: $PAPERMILL_EXIT_CODE"
        echo "Last 20 lines of papermill log:"
        tail -20 "${PAPERMILL_LOG_PATH}" || true
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      # Check for execution errors
      if grep -q "PapermillExecutionError" "${PAPERMILL_LOG_PATH}"; then
        echo "❌ Papermill execution failed - PapermillExecutionError found"
        echo "Last 20 lines of papermill log:"
        tail -20 "${PAPERMILL_LOG_PATH}" || true
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      # Verify output
      if [ -f "${PAPERMILL_OUTPUT_PATH}" ]; then
        OUTPUT_SIZE=$(du -h "${PAPERMILL_OUTPUT_PATH}" | cut -f1)
        echo "✅ SUCCESS: Output notebook created: ${OUTPUT_SIZE}"
        echo -n "success" > "$(results.execution-status.path)"
        echo -n "${PAPERMILL_OUTPUT_PATH}" > "$(results.output-notebook-path.path)"
        echo -n "${PAPERMILL_LOG_PATH}" > "$(results.papermill-log-path.path)"
        echo -n "success" > "$(results.permission-fix-status.path)"
      else
        echo "❌ Output notebook not found"
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      echo ""
      echo "🎉 PRODUCTION EXECUTION WITH RMM HANDLING COMPLETED!"
      echo "✅ Docker Compose compatibility achieved with RAPIDS user UID 1001"
      echo "✅ RMM compatibility issues handled with graceful fallback"
      echo "✅ Kubernetes security best practices followed"
      echo "✅ Init Container pattern successfully implemented"
      echo ""
  
  volumes:
  - name: dshm
    emptyDir:
      medium: Memory
      sizeLimit: 1Gi
  - name: conda-permission-fix
    emptyDir:
      sizeLimit: 5Gi 
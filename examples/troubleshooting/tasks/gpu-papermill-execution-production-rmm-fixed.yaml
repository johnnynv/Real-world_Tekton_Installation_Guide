apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: gpu-papermill-execution-production-init
  namespace: tekton-pipelines
  labels:
    app.kubernetes.io/name: gpu-papermill-execution-production-init
    app.kubernetes.io/component: tekton-task
    app.kubernetes.io/version: "1.0.0"
    production-ready: "true"
    security-model: "init-container-permissions"
    rmm-compatibility: "fixed"
spec:
  description: |
    Production-grade GPU-accelerated Papermill execution with RMM compatibility fixes.
    
    Architecture:
    - Init Container (root): Fixes conda and workspace permissions for RAPIDS user (UID 1001)
    - Main Container (rapids): Executes notebook with RMM error handling
    
    IMPROVEMENTS: Handles RMM compatibility issues with graceful fallback
  
  params:
  - name: notebook-relative-dir
    description: Relative directory containing the notebook
    type: string
    default: "notebooks"
  - name: notebook-filename
    description: Notebook filename to execute
    type: string
    default: "01_scRNA_analysis_preprocessing.ipynb"
  - name: output-notebook
    description: Name for the output notebook
    type: string
    default: "01_scRNA_analysis_preprocessing_output.ipynb"
  - name: container-image
    description: Container image to use for execution
    type: string
    default: "nvcr.io/nvidia/rapidsai/notebooks:25.04-cuda12.8-py3.12"
  - name: enable-rmm-compatibility
    description: Enable RMM compatibility fixes
    type: string
    default: "true"
  
  workspaces:
  - name: shared-storage
    description: Shared workspace for input/output files
    mountPath: /workspace/shared
  
  results:
  - name: execution-status
    description: Status of papermill execution
  - name: output-notebook-path
    description: Path to the executed notebook
  - name: papermill-log-path
    description: Path to the papermill execution log
  - name: permission-fix-status
    description: Status of permission fixes applied by init container
  - name: rmm-compatibility-status
    description: Status of RMM compatibility handling
  
  stepTemplate:
    env:
    - name: NVIDIA_VISIBLE_DEVICES
      value: "all"
    - name: NVIDIA_DRIVER_CAPABILITIES
      value: "compute,utility"
    - name: WORKSPACE_SHARED_PATH
      value: $(workspaces.shared-storage.path)
    - name: DOCKER_WRITEABLE_DIR
      value: "/workspace/shared/artifacts"
    - name: NOTEBOOK_RELATIVED_DIR
      value: $(params.notebook-relative-dir)
    - name: NOTEBOOK_FILENAME
      value: $(params.notebook-filename)
    - name: OUTPUT_NOTEBOOK
      value: $(params.output-notebook)
    - name: EXTRA_PIP_PACKAGES
      value: "anndata==0.11.4 scanpy==1.11.2 rapids-singlecell==0.12.6"
    volumeMounts:
    - name: dshm
      mountPath: /dev/shm
    - name: conda-permission-fix
      mountPath: /opt/conda-writable
  
  steps:
  # Step 1: Init Container - Permission Setup (root privileges)
  - name: init-permission-setup
    image: $(params.container-image)
    computeResources:
      requests:
        memory: 1Gi
        cpu: 500m
      limits:
        memory: 2Gi
        cpu: 1
    securityContext:
      allowPrivilegeEscalation: true
      capabilities:
        drop: ["ALL"]
        add: ["CHOWN", "DAC_OVERRIDE", "FOWNER"]
      runAsNonRoot: false
      runAsUser: 0  # Init container runs as root for permission fixes
      runAsGroup: 0
      seccompProfile:
        type: RuntimeDefault
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  PRODUCTION INIT CONTAINER - RAPIDS USER UID FIX"
      echo "=============================================="
      echo ""
      echo "Running permission setup as: $(whoami) ($(id))"
      
      # Get actual rapids user UID from the container
      if id rapids >/dev/null 2>&1; then
        RAPIDS_UID=$(id -u rapids)
        RAPIDS_GID=$(id -g rapids)
        echo "âœ… RAPIDS user found with actual UID: $(id rapids)"
        echo "   Actual UID: $RAPIDS_UID, GID: $RAPIDS_GID"
      else
        echo "âŒ RAPIDS user not found, this should not happen in this image"
        exit 1
      fi
      
      # Fix conda permissions for ACTUAL rapids user UID
      echo "ðŸ”§ Fixing conda permissions for RAPIDS user (ACTUAL UID: $RAPIDS_UID)..."
      chown -R $RAPIDS_UID:$RAPIDS_GID /opt/conda/ 2>/dev/null || echo "WARNING: Cannot change original conda ownership"
      chmod -R 755 /opt/conda/ 2>/dev/null || echo "WARNING: Cannot change original conda permissions"
      
      # Fix workspace permissions
      echo "ðŸ”§ Fixing workspace permissions for RAPIDS user..."
      if [ -d "${WORKSPACE_SHARED_PATH}" ]; then
        chown -R $RAPIDS_UID:$RAPIDS_GID "${WORKSPACE_SHARED_PATH}" || echo "WARNING: Workspace chown failed"
        chmod -R 755 "${WORKSPACE_SHARED_PATH}" || echo "WARNING: Workspace chmod failed"
      fi
      
      # Create and fix output directories
      mkdir -p "${DOCKER_WRITEABLE_DIR}"
      chown -R $RAPIDS_UID:$RAPIDS_GID "${DOCKER_WRITEABLE_DIR}" || echo "WARNING: Output dir chown failed"
      chmod -R 777 "${DOCKER_WRITEABLE_DIR}" || echo "WARNING: Output dir chmod failed"
      
      # Ensure rapids home directory exists and has correct permissions
      if [ ! -d "/home/rapids" ]; then
        mkdir -p /home/rapids
        echo "âœ… Created /home/rapids directory"
      fi
      chown $RAPIDS_UID:$RAPIDS_GID /home/rapids
      chmod 755 /home/rapids
      echo "âœ… /home/rapids permissions set for UID $RAPIDS_UID"
      
      # Write permission fix status with CORRECT user info
      echo "success" > "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      echo "rapids-user-uid:$RAPIDS_UID" >> "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      echo "rapids-user-gid:$RAPIDS_GID" >> "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt"
      chown $RAPIDS_UID:$RAPIDS_GID "${DOCKER_WRITEABLE_DIR}/permission-fix-status.txt" || true
      
      echo ""
      echo "âœ… PERMISSION SETUP COMPLETED FOR RAPIDS USER"
      echo "ðŸ“‹ Summary:"
      echo "   - RAPIDS user: ACTUAL UID $RAPIDS_UID, GID $RAPIDS_GID"
      echo "   - Conda permissions fixed for rapids user"
      echo "   - Workspace permissions configured"
      echo "   - Output directories prepared"
      echo "   - Ready for main container execution as rapids user UID $RAPIDS_UID"
      echo ""

  # Step 2: RMM Compatibility Setup
  - name: rmm-compatibility-setup
    image: $(params.container-image)
    computeResources:
      requests:
        memory: 2Gi
        cpu: 1
      limits:
        memory: 4Gi
        cpu: 2
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
      runAsNonRoot: true
      runAsUser: 1001  # rapids user
      runAsGroup: 1001
      seccompProfile:
        type: RuntimeDefault
    env:
    - name: HOME
      value: "/home/rapids"
    - name: USER
      value: "rapids"
    - name: PATH
      value: "/home/rapids/.local/bin:/opt/conda/bin:/usr/local/bin:/usr/bin:/bin"
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  RMM COMPATIBILITY SETUP"
      echo "=============================================="
      echo ""
      echo "Running as: $(whoami) ($(id))"
      
      cd "${WORKSPACE_SHARED_PATH}"
      
      # Create RMM compatibility script
      echo "ðŸ“ Creating RMM compatibility script..."
      cat > "${DOCKER_WRITEABLE_DIR}/rmm_compatibility.py" << 'EOF'
import warnings
warnings.filterwarnings("ignore")

def setup_rmm_with_fallback():
    """Setup RMM with graceful fallback to default allocator"""
    try:
        import rmm
        from rmm.allocators.cupy import rmm_cupy_allocator
        import cupy as cp
        
        print("ðŸ”§ Attempting RMM initialization...")
        
        # Try RMM initialization with error handling
        rmm.reinitialize(
            managed_memory=False,
            pool_allocator=False,
            devices=0,
        )
        cp.cuda.set_allocator(rmm_cupy_allocator)
        
        print("âœ… RMM initialized successfully")
        return True
        
    except Exception as e:
        print(f"âš ï¸ RMM initialization failed: {e}")
        print("ðŸ”„ Falling back to default CuPy allocator...")
        
        try:
            import cupy as cp
            # Reset to default allocator
            cp.cuda.set_allocator(None)
            print("âœ… Default CuPy allocator configured")
            return False
        except Exception as fallback_e:
            print(f"âŒ Fallback also failed: {fallback_e}")
            return False

def test_gpu_basic_functionality():
    """Test basic GPU functionality after allocator setup"""
    try:
        import cupy as cp
        device_count = cp.cuda.runtime.getDeviceCount()
        print(f"âœ… GPU devices detected: {device_count}")
        
        if device_count > 0:
            # Test basic GPU operation
            x = cp.array([1, 2, 3])
            y = cp.sum(x)
            print(f"âœ… Basic GPU operation successful: {y}")
            return True
        else:
            print("âŒ No GPU devices found")
            return False
            
    except Exception as e:
        print(f"âŒ GPU functionality test failed: {e}")
        return False

if __name__ == "__main__":
    print("ðŸš€ Starting RMM compatibility setup...")
    
    rmm_success = setup_rmm_with_fallback()
    gpu_success = test_gpu_basic_functionality()
    
    if gpu_success:
        print("âœ… GPU functionality verified")
        print("ready" if rmm_success else "fallback")
    else:
        print("âŒ GPU functionality verification failed")
        print("failed")
EOF
      
      # Run RMM compatibility setup
      echo "ðŸš€ Running RMM compatibility setup..."
      PYTHON_BIN="/opt/conda/bin/python"
      
      if [ -x "$PYTHON_BIN" ]; then
        $PYTHON_BIN "${DOCKER_WRITEABLE_DIR}/rmm_compatibility.py" > "${DOCKER_WRITEABLE_DIR}/rmm_setup.log" 2>&1
        RMM_EXIT_CODE=$?
        
        echo "ðŸ“‹ RMM compatibility setup results:"
        cat "${DOCKER_WRITEABLE_DIR}/rmm_setup.log"
        
        if [ $RMM_EXIT_CODE -eq 0 ]; then
          echo "âœ… RMM compatibility setup completed successfully"
          echo -n "success" > "$(results.rmm-compatibility-status.path)"
        else
          echo "âŒ RMM compatibility setup failed"
          echo -n "failed" > "$(results.rmm-compatibility-status.path)"
        fi
      else
        echo "âŒ Python not accessible for RMM setup"
        echo -n "failed" > "$(results.rmm-compatibility-status.path)"
      fi
      
      echo ""
      echo "ðŸ RMM COMPATIBILITY SETUP COMPLETED"
      echo ""
  
  # Step 3: Main Container - Notebook Execution with RMM handling
  - name: execute-notebook-with-rmm-handling
    image: $(params.container-image)
    computeResources:
      requests:
        nvidia.com/gpu: 1
        memory: 16Gi
        cpu: 4
      limits:
        nvidia.com/gpu: 1
        memory: 32Gi
        cpu: 8
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
        add: ["IPC_LOCK", "SYS_RESOURCE"]
      runAsNonRoot: true
      runAsUser: 1001  # CORRECT: Use actual RAPIDS user UID 1001
      runAsGroup: 1001
      seccompProfile:
        type: RuntimeDefault
    env:
    - name: HOME
      value: "/home/rapids"
    - name: USER
      value: "rapids"
    - name: PATH
      value: "/home/rapids/.local/bin:/opt/conda/bin:/usr/local/bin:/usr/bin:/bin"
    - name: PYTHONPATH
      value: "/opt/conda/lib/python3.12/site-packages"
    - name: CONDA_DEFAULT_ENV
      value: "base"
    script: |
      #!/bin/bash
      set -eu
      
      echo "=============================================="
      echo "  PRODUCTION NOTEBOOK EXECUTION WITH RMM HANDLING"
      echo "=============================================="
      echo ""
      echo "Running as: $(whoami) ($(id))"
      echo "Home: $HOME"
      echo "Path: $PATH"
      echo ""
      
      # Verify we're running as the correct user
      CURRENT_UID=$(id -u)
      if [ "$CURRENT_UID" != "1001" ]; then
        echo "âŒ ERROR: Expected to run as UID 1001 (rapids), but running as UID $CURRENT_UID"
        exit 1
      else
        echo "âœ… Correctly running as RAPIDS user (UID 1001)"
      fi
      
      # Apply Docker Compose compatible memory settings
      echo "ðŸ”§ Applying Docker Compose compatible memory settings..."
      ulimit -l unlimited 2>/dev/null || echo "WARNING: Cannot set unlimited memlock"
      ulimit -s 67108864 2>/dev/null || echo "WARNING: Cannot set stack size"
      
      cd "${WORKSPACE_SHARED_PATH}"
      
      # Verify GPU availability
      echo "ðŸ” Checking GPU availability..."
      nvidia-smi --query-gpu=name,memory.total --format=csv,noheader || echo "WARNING: nvidia-smi failed"
      
      # Verify notebook exists
      NOTEBOOK_PATH="${NOTEBOOK_RELATIVED_DIR}/${NOTEBOOK_FILENAME}"
      if [ ! -f "${NOTEBOOK_PATH}" ]; then
        echo "âŒ Notebook not found: ${NOTEBOOK_PATH}"
        find . -name "*.ipynb" -type f | head -5
        exit 1
      fi
      
      echo "âœ… Notebook found: ${NOTEBOOK_PATH}"
      
      # Setup Python environment
      echo "ðŸ Setting up Python environment as RAPIDS user (UID 1001)..."
      PYTHON_BIN="/opt/conda/bin/python"
      PIP_BIN="/opt/conda/bin/pip"
      
      # Verify Python environment access
      echo "ðŸ” Python environment verification:"
      $PYTHON_BIN --version && echo "âœ… Python OK" || (echo "âŒ Python failed" && exit 1)
      $PIP_BIN --version && echo "âœ… pip OK" || (echo "âŒ pip failed" && exit 1)
      
      # Install dependencies
      echo "ðŸ“¦ Installing dependencies as RAPIDS user..."
      $PIP_BIN install --user --quiet --no-cache-dir papermill ipykernel jupyter || {
        echo "âŒ Failed to install papermill"
        exit 1
      }
      
      # Install additional packages
      if [ -n "${EXTRA_PIP_PACKAGES:-}" ]; then
        echo "ðŸ“¦ Installing additional packages..."
        $PIP_BIN install --user --quiet --no-cache-dir ${EXTRA_PIP_PACKAGES} || echo "WARNING: Some pip packages failed"
      fi
      
      # Check RMM compatibility status
      echo "ðŸ” Checking RMM compatibility status..."
      if [ -f "${DOCKER_WRITEABLE_DIR}/rmm_setup.log" ]; then
        echo "ðŸ“‹ RMM setup results:"
        cat "${DOCKER_WRITEABLE_DIR}/rmm_setup.log"
      fi
      
      # Create notebook preprocessing script for RMM handling
      echo "ðŸ“ Creating notebook preprocessing script..."
      cat > "${DOCKER_WRITEABLE_DIR}/notebook_preprocessor.py" << 'EOF'
import nbformat
import sys

def preprocess_notebook_for_rmm(input_path, output_path):
    """Preprocess notebook to handle RMM initialization gracefully"""
    print(f"ðŸ“ Preprocessing notebook: {input_path}")
    
    # Read the original notebook
    with open(input_path, 'r') as f:
        nb = nbformat.read(f, as_version=4)
    
    # Find the RMM initialization cell (usually cell 2 or 3)
    rmm_cell_found = False
    for i, cell in enumerate(nb.cells):
        if cell.cell_type == 'code' and 'rmm.reinitialize' in cell.source:
            print(f"ðŸ”§ Found RMM cell at index {i}, applying compatibility fix...")
            
            # Replace the problematic RMM code with error-handled version
            new_source = '''import warnings
warnings.filterwarnings("ignore")

# RMM initialization with error handling
try:
    import rmm
    from rmm.allocators.cupy import rmm_cupy_allocator
    import cupy as cp
    
    print("ðŸ”§ Attempting RMM initialization...")
    rmm.reinitialize(
        managed_memory=False,
        pool_allocator=False,
        devices=0,
    )
    cp.cuda.set_allocator(rmm_cupy_allocator)
    print("âœ… RMM initialized successfully")
    
except Exception as e:
    print(f"âš ï¸ RMM initialization failed: {e}")
    print("ðŸ”„ Using default CuPy allocator")
    
    try:
        import cupy as cp
        cp.cuda.set_allocator(None)  # Use default allocator
        print("âœ… Default allocator configured")
    except Exception as fallback_e:
        print(f"âŒ Fallback failed: {fallback_e}")
        # Continue anyway, might still work'''
            
            cell.source = new_source
            rmm_cell_found = True
            break
    
    if not rmm_cell_found:
        print("â„¹ï¸ No RMM initialization cell found, notebook unchanged")
    
    # Write the preprocessed notebook
    with open(output_path, 'w') as f:
        nbformat.write(nb, f)
    
    print(f"âœ… Preprocessed notebook saved to: {output_path}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python notebook_preprocessor.py input.ipynb output.ipynb")
        sys.exit(1)
    
    input_notebook = sys.argv[1]
    output_notebook = sys.argv[2]
    
    preprocess_notebook_for_rmm(input_notebook, output_notebook)
EOF
      
      # Preprocess the notebook to handle RMM issues
      PREPROCESSED_NOTEBOOK="${DOCKER_WRITEABLE_DIR}/preprocessed_${NOTEBOOK_FILENAME}"
      echo "ðŸ”§ Preprocessing notebook for RMM compatibility..."
      $PYTHON_BIN "${DOCKER_WRITEABLE_DIR}/notebook_preprocessor.py" "${NOTEBOOK_PATH}" "${PREPROCESSED_NOTEBOOK}"
      
      # Setup GPU environment
      export CUDA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-"all"}
      export CUPY_CACHE_DIR="${HOME}/.cupy"
      export NUMBA_CACHE_DIR="${HOME}/.numba"
      mkdir -p "${CUPY_CACHE_DIR}" "${NUMBA_CACHE_DIR}" 2>/dev/null || echo "WARNING: Cannot create cache dirs"
      
      # Find papermill executable
      PAPERMILL_BIN=""
      if [ -x "/home/rapids/.local/bin/papermill" ]; then
        PAPERMILL_BIN="/home/rapids/.local/bin/papermill"
      elif [ -x "/opt/conda/bin/papermill" ]; then
        PAPERMILL_BIN="/opt/conda/bin/papermill"
      else
        echo "âŒ papermill not found after installation"
        exit 1
      fi
      
      # Execute preprocessed notebook with Papermill
      echo "ðŸš€ Executing preprocessed notebook with Papermill..."
      PAPERMILL_OUTPUT_PATH="${DOCKER_WRITEABLE_DIR}/${OUTPUT_NOTEBOOK}"
      PAPERMILL_LOG_PATH="${DOCKER_WRITEABLE_DIR}/papermill.log"
      
      echo "Command: $PAPERMILL_BIN \"${PREPROCESSED_NOTEBOOK}\" \"${PAPERMILL_OUTPUT_PATH}\" --log-output --log-level DEBUG --progress-bar --report-mode --kernel python3"
      
      # Execute with EXACT same parameters as GitHub Actions
      PAPERMILL_EXIT_CODE=0
      $PAPERMILL_BIN "${PREPROCESSED_NOTEBOOK}" "${PAPERMILL_OUTPUT_PATH}" \
          --log-output \
          --log-level DEBUG \
          --progress-bar \
          --report-mode \
          --kernel python3 2>&1 | tee "${PAPERMILL_LOG_PATH}" || PAPERMILL_EXIT_CODE=$?
      
      # Check results
      if [ $PAPERMILL_EXIT_CODE -ne 0 ]; then
        echo "âŒ Papermill execution failed with exit code: $PAPERMILL_EXIT_CODE"
        echo "Last 20 lines of papermill log:"
        tail -20 "${PAPERMILL_LOG_PATH}" || true
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      # Check for execution errors
      if grep -q "PapermillExecutionError" "${PAPERMILL_LOG_PATH}"; then
        echo "âŒ Papermill execution failed - PapermillExecutionError found"
        echo "Last 20 lines of papermill log:"
        tail -20 "${PAPERMILL_LOG_PATH}" || true
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      # Verify output
      if [ -f "${PAPERMILL_OUTPUT_PATH}" ]; then
        OUTPUT_SIZE=$(du -h "${PAPERMILL_OUTPUT_PATH}" | cut -f1)
        echo "âœ… SUCCESS: Output notebook created: ${OUTPUT_SIZE}"
        echo -n "success" > "$(results.execution-status.path)"
        echo -n "${PAPERMILL_OUTPUT_PATH}" > "$(results.output-notebook-path.path)"
        echo -n "${PAPERMILL_LOG_PATH}" > "$(results.papermill-log-path.path)"
        echo -n "success" > "$(results.permission-fix-status.path)"
      else
        echo "âŒ Output notebook not found"
        echo -n "failed" > "$(results.execution-status.path)"
        exit 1
      fi
      
      echo ""
      echo "ðŸŽ‰ PRODUCTION EXECUTION WITH RMM HANDLING COMPLETED!"
      echo "âœ… Docker Compose compatibility achieved with RAPIDS user UID 1001"
      echo "âœ… RMM compatibility issues handled with graceful fallback"
      echo "âœ… Kubernetes security best practices followed"
      echo "âœ… Init Container pattern successfully implemented"
      echo ""
  
  volumes:
  - name: dshm
    emptyDir:
      medium: Memory
      sizeLimit: 1Gi
  - name: conda-permission-fix
    emptyDir:
      sizeLimit: 5Gi 